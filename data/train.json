[
  {
    "question": "操作系统是什么？",
    "answer": "操作系统是控制管理计算机系统的硬软件，分配调度资源的系统软件。"
  },
  {
    "question": "操作系统需要实现什么目标？",
    "answer": "方便性，有效性（提高系统资源的利用率、提高系统的吞吐量），可扩充性，开放性。"
  },
  {
    "question": "操作系统有哪些基本功能？",
    "answer": "1.统一管理计算机资源。2.实现了对计算机资源的抽象。3.提供了用户与计算机之间的接口。"
  },
  {
    "question": "计算机资源有哪些？",
    "answer": "处理器资源，IO设备资源，存储器资源，文件资源"
  },
  {
    "question": "用户与计算机之间的接口有哪些？",
    "answer": "GUI（图形用户界面），命令形式，系统调用形式。"
  },
  {
    "question": "操作系统最基本的特征是什么？",
    "answer": "最基本的特征，互为存在条件：并发，共享"
  },
  {
    "question": "操作系统有哪些特征？",
    "answer": "并行、并发、共享性、虚拟性、异步性"
  },
  {
    "question": "什么是并行？",
    "answer": "并行指两个或多个事件可以在同一个时刻发生，多核CPU可以实现并行，一个cpu同一时刻只有一个程序在运行"
  },
  {
    "question": "什么是并发？",
    "answer": "并发指两个或多个事件可以在同一个时间间隔发生，用户看起来是每个程序都在运行，实际上是每个程序都交替执行。"
  },
  {
    "question": "什么是共享性？",
    "answer": "操作系统的中资源可供多个并发的程序共同使用，这种形式称之为资源共享。"
  },
  {
    "question": "资源共享有哪些方式？",
    "answer": "两种：互斥共享、同时访问"
  },
  {
    "question": "什么是互斥共享？",
    "answer": "互斥共享：当资源被程序占用时，其它想使用的程序只能等待。"
  },
  {
    "question": "什么是同时访问？",
    "answer": "某种资源并发的被多个程序访问。"
  },
  {
    "question": "虚拟和异步性的前提是什么？",
    "answer": "并发性"
  },
  {
    "question": "什么是虚拟性？",
    "answer": "虚拟性：表现为把一个物理实体转变为若干个逻辑实体。"
  },
  {
    "question": "什么是时分复用技术？",
    "answer": "时分复用技术：资源在时间上进行复用，不同程序并发使用，多道程序分时使用计算机的硬件资源，提高资源的利用率。"
  },
  {
    "question": "什么是空分复用技术？",
    "answer": "用来实现虚拟磁盘（物理磁盘虚拟为逻辑磁盘，电脑上的C盘、D盘等）、虚拟内存（在逻辑上扩大程序的存储容量）等，提高资源的利用率，提高编程效率。"
  },
  {
    "question": "什么是异步性？",
    "answer": "在多道程序环境下，允许多个进程并发执行，但由于资源等因素的限制，使进程的执行以“停停走走”的方式运行，而且每个进程执行的情况（运行、暂停、速度、完成）也是未知的。"
  },
  {
    "question": "什么是中断？",
    "answer": "中断（Interrupt）是一种硬件或软件机制，用于暂停当前正在执行的程序，转而去处理更紧急或优先级更高的任务，完成后再返回原程序继续执行。它是计算机系统高效响应外部事件、实现多任务协作的核心机制之一。"
  },
  {
    "question": "中断机制有什么作用？",
    "answer": "为了在多道批处理系统中让用户进行交互"
  },
  {
    "question": "中断产生时计算机如何进行反应？",
    "answer": "1.发生中断时，CPU立马切换到管态，开展管理工作；（管态又叫特权态，系统态或核心态，是操作系统管理的程序执行时，机器所处的状态。）2.发生中断后，当前运行的进程回暂停运行，由操作系统内核对中断进行处理；3.对于不同的中断信号，会进行不同的处理。"
  },
  {
    "question": "中断分为哪几类？",
    "answer": "两类：内终端、外中断"
  },
  {
    "question": "什么是内中断？",
    "answer": "内中断（也叫“异常”、“例外”、“陷入”）------- 信号来源：CPU内部，与当前执行指令有关；"
  },
  {
    "question": "什么是外中断？",
    "answer": "外中断（中断）------信号来源：CPU外部，与当前执行指令无关。"
  },
  {
    "question": "外中断的处理过程是怎样的？",
    "answer": "1.每执行完一个指令后，CPU都需要检查当前是否有外部中断 信号；2.如果检查到外部中断信号，则需要保护被中断进程的CPU环境（如程序状态字PSW，程序计数器PC、各种通用寄存器）把他们存储在PCB（进程控制块中）；3.根据中断信号类型转入相应的中断处理程序；4.恢复原进程的CPU环境并退出中断，返回原进程继续执行。"
  },
  {
    "question": "为什么需要进程？",
    "answer": "1.进程是系统进行资源分配和调度的基本单位；2.进程作为程序独立运行的载体保障程序正常执行；3.进程的存在使得操作系统资源的利用率大幅提升。"
  },
  {
    "question": "什么是进程控制块？",
    "answer": "进程控制块（PCB）：用于描述和控制进程运行的通用数据结构,记录进程当前状态和控制进程运行的全部信息，是进程存在的唯一标识。"
  },
  {
    "question": "什么是进程？",
    "answer": "系统进行资源分配和调度的基本单位。"
  },
  {
    "question": "什么是线程？",
    "answer": "操作系统进行运行调度的最小单位。"
  },
  {
    "question": "进程和线程有什么区别？",
    "answer": "1.进程是资源分配的基本单位，而线程不拥有资源2.进程是独立调度的基本单位，线程是独立调度的最小单位3.进程系统开销大，线程系统开销小4.通信上，进程有IPC，线程通过读写统一进程数据通信"
  },
  {
    "question": "进程管理的五状态模型是哪五状态？",
    "answer": "就绪，执行，阻塞，创建，终止"
  },
  {
    "question": "什么是执行状态？",
    "answer": "进程获得CPU，其程序正在执行。"
  },
  {
    "question": "什么是阻塞状态？",
    "answer": "进程因某种原因放弃CPU的状态，阻塞进程以队列的形式放置。"
  },
  {
    "question": "什么是创建状态？",
    "answer": "创建进程时拥有PCB但其它资源尚未就绪。"
  },
  {
    "question": "什么是终止状态？",
    "answer": "进程结束由系统清理或者归还PCB的状态。"
  },
  {
    "question": "什么是生产者-消费者问题？",
    "answer": "生产者-消费者问题：有一群生产者进程在生产产品，并将这些产品提供给消费者进程进行消费，生产者进程和消费者进程可以并发执行，在两者之间设置了一个具有n个缓冲区的缓冲池，生产者进程需要将所生产的产品放到缓冲区中（+1操作），消费者进程可以从缓冲区取走产品消费（-1操作）。"
  },
  {
    "question": "什么是哲学家进餐问题？",
    "answer": "哲学家进餐问题：有5个哲学家，他们的生活方式是交替的思考和进餐，哲学家们共同使用一张圆桌，分别坐在5张椅子上，圆桌上有5只碗和5只筷子。平时哲学家们只进行思考，饥饿时则试图取靠近他们的左右两只筷子，只有两只筷子都被拿到的时候才能进餐，否则等待，进餐完毕后，放下左右筷子进行思考。"
  },
  {
    "question": "什么是临界资源？",
    "answer": "临界资源指的是一些虽作为共享资源却又无法同时被多个线程共同访问的共享资源。当有进程在使用临界资源时，其他进程必须依据操作系统的同步机制等待占用进程释放该共享资源才可重新竞争使用共享资源。"
  },
  {
    "question": "进程同步有什么作用？",
    "answer": "进程同步的作用：对竞争资源在多进程间进行使用次序的协调，使得并发执行的多个进程之间可以有效使用资源和相互合作。"
  },
  {
    "question": "进程同步遵循哪四原则？",
    "answer": "空闲让进、忙则等待、有限等待、让权等待"
  },
  {
    "question": "进程同步的方法有哪些？",
    "answer": "例如：共享内存、域套接字"
  },
  {
    "question": "进程间共享内存的内涵是什么？",
    "answer": "1.共享存储允许不相关的进程访问同一片物理内存2.共享内存是两个进程之间共享和传递数据最快的方式；3.共享内存未提供同步机制，需要借助其他机制管理访问；"
  },
  {
    "question": "线程同步的方法有哪些？",
    "answer": "例如：互斥锁、自旋锁、读写锁、条件变量"
  },
  {
    "question": "什么是互斥锁？",
    "answer": "互斥锁：最简单的一种线程同步方法，会阻塞线程"
  },
  {
    "question": "什么是自旋锁？",
    "answer": "自旋锁：避免切换的一种线程同步方法，属于 “忙等待”"
  },
  {
    "question": "什么是读写锁？",
    "answer": "读写锁：为 “读多写少” 的资源设计的线程同步方法，可以显著提高性能"
  },
  {
    "question": "什么是条件变量？",
    "answer": "条件变量：相对复杂的一种线程同步方法，有更灵活的使用场景"
  },
  {
    "question": "Linux进程管理的类型有哪些？",
    "answer": "前台进程、后台进程、守护进程"
  },
  {
    "question": "什么是前台进程？",
    "answer": "前台进程：具有终端，可以和用户交互"
  },
  {
    "question": "什么是后台进程？",
    "answer": "后台进程：没有占用终端，基本不和用户交互，优先级比前台进程低（将需要执行的命令以“&”符号结束）；"
  },
  {
    "question": "什么是守护进程？",
    "answer": "守护进程：特殊的后台进程，在系统引导时启动，一直运行直到系统关闭（进程名字以“d”结尾的一般都是守护进程），如crond、sshd、httpd、mysqld…"
  },
  {
    "question": "进程的标记有哪些？",
    "answer": "进程ID，进程的状态标记"
  },
  {
    "question": "什么是进程ID？",
    "answer": "进程ID：非负整数，进程的唯一标记，每个进程拥有不同的ID"
  },
  {
    "question": "什么是进程的状态标记？",
    "answer": "进程的状态标记：R：进程处于运行状态，S：进程处于睡眠状态，进程正在处于 IO 等待的睡眠状态，T：进程正处于暂停状态，Z，进程正处于退出状态，或僵尸进程"
  },
  {
    "question": "操作Linux进程的相关命令？",
    "answer": "1.ps命令：列出当前的进程，结合-aux可以打印进程的详细信息（ps -aux）；2.top命令：查看所有进程的状态；3.kill命令：给进程发送信号。"
  },
  {
    "question": "什么是进程调度？",
    "answer": "指计算机通过决策决定哪个就绪进程可以获得CPU使用权。"
  },
  {
    "question": "什么时候需要进程调度？",
    "answer": "1.主动放弃：进程正常终止；运行过程中发生异常而终止；主动阻塞（如等待I/O）；2.被动放弃：分给进程的时间片用完；有更高优先级的进程进入就绪队列；有更紧急的事情需要处理（如I/O中断）；"
  },
  {
    "question": "进程调度方式有哪些？",
    "answer": "非抢占式调度、抢占式调度"
  },
  {
    "question": "什么是非抢占式调度？",
    "answer": "非抢占式调度：只能由当前运行的进程主动放弃CPU；"
  },
  {
    "question": "什么是抢占式调度？",
    "answer": "抢占式调度：可由操作系统剥夺当前进程的CPU使用权。"
  },
  {
    "question": "进程调度的三大机制是什么？",
    "answer": "就绪队列的排队机制,选择运行进程的委派机制,新老进程的上下文切换机制"
  },
  {
    "question": "什么是就绪队列的排队机制？",
    "answer": "为了提高进程调度的效率，将就绪进程按照一定的方式排成队列，以便调度程序可以最快找到就绪进程。"
  },
  {
    "question": "什么是选择运行进程的委派机制？",
    "answer": "调度程序以一定的策略，选择就绪进程，将CPU资源分配给它。"
  },
  {
    "question": "什么是新老进程的上下文切换机制？",
    "answer": "新老进程的上下文切换机制：保存当前进程的上下文信息，装入被委派执行进程的运行上下文。"
  },
  {
    "question": "进程调度算法有哪些？",
    "answer": "先来先服务，短进程优先调度，高优先权优先调度，时间片轮转"
  },
  {
    "question": "什么是先来先服务算法？",
    "answer": "按照在就绪队列中的先后顺序执行。"
  },
  {
    "question": "什么是短进程优先调度算法？",
    "answer": "优先选择就绪队列中估计运行时间最短的进程，不利于长作业进程的执行。"
  },
  {
    "question": "什么是高优先权优先调度算法？",
    "answer": "进程附带优先权，优先选择权重高的进程，可以使得紧迫的任务优先处理。"
  },
  {
    "question": "什么是时间片轮转调度算法？",
    "answer": "按照FIFO的原则排列就绪进程，每次从队列头部取出待执行进程，分配一个时间片执行，是相对公平的调度算法，但是不能保证就是响应用户。"
  },
  {
    "question": "什么是死锁？",
    "answer": "两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。永远在互相等待的进程称为死锁进程。"
  },
  {
    "question": "什么是饥饿？",
    "answer": "由于长期得不到资源导致进程无法推进"
  },
  {
    "question": "什么是死循环？",
    "answer": "代码逻辑BUG"
  },
  {
    "question": "死锁是怎么产生的？",
    "answer": "竞争资源（共享资源数量不满足各进程需求）、进程调度顺序不当，当调度顺序为A->B->C->D时会产生死锁，但改为A->D->B->C则不会产生。"
  },
  {
    "question": "死锁的四个必要条件是什么？",
    "answer": "互斥条件、请求保持条件、不可剥夺条件、环路等待条件"
  },
  {
    "question": "什么是互斥条件？",
    "answer": "必须互斥使用资源才会产生死锁"
  },
  {
    "question": "什么是请求保持条件？",
    "answer": "进程至少保持一个资源，又提出新的资源请求，新资源被占用，请求被阻塞，被阻塞的进程不释放自己保持的资源；"
  },
  {
    "question": "什么是不可剥夺条件？",
    "answer": "进程获得的资源在未完成使用前不能被剥夺（包括OS），只能由进程自身释放"
  },
  {
    "question": "什么是环路等待条件？",
    "answer": "发生死锁时，必然存在进程-资源环形链,环路等待不一定造成死锁，但是死锁一定有循环等待。"
  },
  {
    "question": "死锁的处理策略是什么？",
    "answer": "预防死锁、银行家算法、死锁的检测和解除"
  },
  {
    "question": "预防死锁的方法有哪些？",
    "answer": "破坏四个必要条件的中一个或多个:互斥、请求保持、不可剥夺和环路等待条件。"
  },
  {
    "question": "什么是银行家算法？",
    "answer": "检查当前资源剩余是否可以满足某个进程的最大需求；如果可以，就把该进程加入安全序列，等待进程允许完成，回收所有资源；重复1，2，直到当前没有线程等待资源"
  },
  {
    "question": "死锁的检测和解除有哪些方法？",
    "answer": "死锁检测算法，资源剥夺法，撤销进程法（终止进程法），进程回退法"
  },
  {
    "question": "内存分配的过程是怎样的？",
    "answer": "单一连续分配（已经过时）、固定分区分配、动态分区分配（根据实际需要，动态的分配内存）。"
  },
  {
    "question": "动态分区分配算法有哪些？",
    "answer": "首次适应算法、最佳适应算法、快速适应算法"
  },
  {
    "question": "什么是首次适应法？",
    "answer": "分配内存时，从开始顺序查找适合内存区，若无合适内存区，则分配失败，每次从头部开始，使得头部地址空间不断被划分"
  },
  {
    "question": "什么是最佳适应法？",
    "answer": "要求空闲区链表按照容量大小排序，遍历以找到最佳适合的空闲区（会留下越来越多的内部碎片）"
  },
  {
    "question": "什么是快速适应法？",
    "answer": "要求有多个空闲区链表，每个空闲区链表存储一种容量的空闲区。"
  },
  {
    "question": "回收区在空闲区下方内存回收过程？",
    "answer": "不需要新建空闲链表节点；只需要把空闲区1的容量增大即可"
  },
  {
    "question": "回收区在空闲区上方内存回收过程？",
    "answer": "将回收区与空闲区合并；新的空闲区使用回收区的地址"
  },
  {
    "question": "回收区在空闲区中间方内存回收过程？",
    "answer": "将空闲区1、空闲区2和回收区合并；新的空闲区使用空闲区1的地址"
  },
  {
    "question": "仅仅剩余回收区内存回收过程？",
    "answer": "为回收区创建新的空闲节点；插入到相应的空闲区链表中去"
  },
  {
    "question": "什么是页式存储管理？",
    "answer": "将进程逻辑空间等分成若干大小的页面，相应的把物理内存空间分成与页面大小的物理块，以页面为单位把进程空间装进物理内存中分散的物理块。"
  },
  {
    "question": "什么是段式存储管理？",
    "answer": "将进程逻辑空间分成若干段（不等分），段的长度由连续逻辑的长度决定。"
  },
  {
    "question": "什么是段页式存储管理？",
    "answer": "现将逻辑空间按照段式管理分成若干段，再将内存空间按照页式管理分成若干页，分页可以有效提高内存利用率，分段可以更好的满足用户需求。"
  },
  {
    "question": "页式和段式存储管理的区别？",
    "answer": "段式存储和页式存储都离散地管理了进程的逻辑空间；页是物理单位，段是逻辑单位；分页是为了合理利用空间，分段是满足用户要求页大小由硬件固定，段长度可动态变化；页表信息是一维的，段表信息是二维的；"
  },
  {
    "question": "什么是虚拟内存？",
    "answer": "是操作系统内存管理的关键技术，使得多道程序运行和大程序运行成为现实，把程序使用内存划分，将部分暂时不使用的内存放置在辅存，实际是对物理内存的扩充。"
  },
  {
    "question": "什么是局部性原理？",
    "answer": "指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。"
  },
  {
    "question": "虚拟内存的置换算法有哪些？",
    "answer": "先进先出（FIFO）、最不经常使用（LFU）、最近最少使用（LRU）"
  },
  {
    "question": "虚拟内存的特征有哪些？",
    "answer": "多次性、对换性、虚拟性"
  },
  {
    "question": "多次性的含义？",
    "answer": "无需再作业运行时一次性全部装入内存，而是允许被分成多次调入内存；"
  },
  {
    "question": "对换性的含义？",
    "answer": "无需在作业运行时一直常驻内存，而是允许在作业运行过程中，将作业换入、换出；"
  },
  {
    "question": "虚拟性的含义？",
    "answer": "从逻辑上扩充了内存的容量，使用户看到的内存用来，远大于实际的容量；"
  },
  {
    "question": "Buddy内存管理算法的定义？",
    "answer": "经典的内存管理算法，为解决内存外碎片的问题，算法基于计算机处理二进制的优势具有极高的效率。"
  },
  {
    "question": "Linux交换空间的定义？",
    "answer": "交换空间（Swap）是磁盘的一个分区，Linux内存满时，会把一些内存交换至Swap空间，Swap空间是初始化系统时配置的。"
  },
  {
    "question": "逻辑结构的文件类型有哪些？",
    "answer": "有结构文件（文本文件，文档，媒体文件）、无结构文件（二进制文件、链接库）"
  },
  {
    "question": "顺序文件的定义？",
    "answer": "按顺序放在存储介质中的文件，在逻辑文件当中存储效率最高，但不适合存储可变长文件。"
  },
  {
    "question": "索引文件的定义？",
    "answer": "为解决可变长文件存储而发明，需要配合索引表存储。"
  },
  {
    "question": "辅助的存储方式有哪些？",
    "answer": "连续分配（读取文件容易，速度快）、链接分配（隐式链接和显式链接）、索引分配"
  },
  {
    "question": "辅存的存储空间管理方式有哪些？",
    "answer": "空闲表、空闲链表、位示图"
  },
  {
    "question": "目录树的定义？",
    "answer": "使得任何文件或目录都有唯一的路径"
  },
  {
    "question": "Linux的文件系统有哪些？",
    "answer": "FAT、NTFS（对FAT进行改进）、EXT2/3/4（扩展文件系统，Linux的文件系统）"
  },
  {
    "question": "I/O设备的基本概念？",
    "answer": "将数据输入输出计算机的外部设备"
  },
  {
    "question": "按照使用特性分类I/O设备可分为？",
    "answer": "存储设备（内存、磁盘、U盘）和交互IO设备（键盘、显示器、鼠标）"
  },
  {
    "question": "按照信息交换分类I/O设备可分为？",
    "answer": "块设备（磁盘、SD卡）和字符设备（打印机、shell终端）"
  },
  {
    "question": "按照设备共享属性分类I/O设备可分为？",
    "answer": "独占设备，共享设备，虚拟设备"
  },
  {
    "question": "按照传输速率分类I/O设备可分为？",
    "answer": "低速设备，高速设备"
  },
  {
    "question": "IO设备的缓存区的作用？",
    "answer": "减少CPU处理IO请求的频率，提高CPU与IO设备之间的并行性。"
  },
  {
    "question": "SPOOLing技术的定义？",
    "answer": "虚拟设备技术，把同步调用低速设备改为异步调用，在输入、输出之间增加了排队转储环节(输入井、输出井)，SPoOLing负责输入（出）井与低速设备之间的调度，逻辑上，进程直接与高速设备交互，减少了进程的等待时间。"
  },
  {
    "question": "线程池的定义？",
    "answer": "线程池是存放多个线程的容器，CPU调度线程执行后不会销毁线程，将线程放回线程池重新利用。"
  },
  {
    "question": "为什么要使用线程池？",
    "answer": "线程是稀缺资源 ，不应该频繁创建和销毁；架构解耦，业务创建和业务处理解耦，更加优雅；线程池是使用线程的最佳实践。"
  },
  {
    "question": "什么是队列？",
    "answer": "用于存放多个元素，是存放各种元素的“池”。"
  },
  {
    "question": "队列实现的基本功能有什么？",
    "answer": "获取当前队列元素数量，往队列放入元素，往队列取出元素。"
  },
  {
    "question": "Task的实现的基本功能？",
    "answer": "任务参数，任务唯一标记（UUID），任务具体的执行逻辑"
  },
  {
    "question": "怎么实现任务处理线程ProcessThread？",
    "answer": "任务处理线程需要不断地从任务队列里取任务执行，任务处理线程需要有一个标记，标记线程什么时候应该停止。"
  },
  {
    "question": "ProcessThread实现的基本功能？",
    "answer": "基本属性（任务队列、标记），线程执行的逻辑（run），线程停止（stop）"
  },
  {
    "question": "怎么实现任务处理线程池Pool？",
    "answer": "存放多个任务处理线程，负责多个线程的启停，管理向线程池的提交任务，下发给线程去执行。"
  },
  {
    "question": "Pool实现的基本过程？",
    "answer": "基本属性，提交任务（put，batch_put），线程启停（start，join），线程池大小（size）"
  },
  {
    "question": "怎样实现异步任务处理AsyncTask？",
    "answer": "给任务添加一个标记，任务完成后，则标记为完成；任务完成时可直接获取任务运行结果；任务未完成时，获取任务结果，会阻塞获取线程"
  },
  {
    "question": "AsyncTask主要实现的两个函数？",
    "answer": "设置运行结果（set_result），获取运行结果（get_result)"
  },
  {
    "question": "什么是银行家算法？",
    "answer": "检查当前资源剩余是否可以满足某个进程的最大需求；如果可以，就把该进程加入安全序列，等待进程允许完成，回收所有资源；重复1，2，直到当前没有线程等待资源"
  },
  {
    "question": "怎样检测和删除死锁？",
    "answer": "死锁检测算法，资源剥夺法，撤销进程法（终止进程法），进程回退法"
  },
  {
    "question": "预防死锁的方法有哪些？",
    "answer": "破坏互斥条件、破坏请求保持条件、破坏不可剥夺条件、破坏环路等待条件"
  }
]